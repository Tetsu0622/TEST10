// DSP related functions and data //


/*
 *      Original copyright:
 *      Copyright (C) 2011 by Jonathan Naylor, G4KLX
 *
 *      Copyright (C) 2011 by Kristoff Bonne, ON1ARF
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
 *      the Free Software Foundation; version 2 of the License.
 *
 *      This program is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *      GNU General Public License for more details.
 */

// These is the low-level DSP functions that make up the gmsk demodulator:
// firfilter
// modulate
// demodulate

// This code is largely based on the code from the "pcrepeatercontroller"
// project, written by Jonathan Naylor 
// More info: 
// http://groups.yahoo.com/group/pcrepeatercontroller



// Changes:
// Convert FIR-filter to integer
// Change PLL values so to make PLLINC and SMALLPLLINC match integer-boundaries
// Concert C++ to C


// Version 20111106: initial release demodulation
// Version 20111213: initial release modulation
// Version 20120105: no change



// global data


#if _USEFLOAT == 1

float coeffs_table_modulate [] = {
// gaussfir(0.5, 2, 20)
	3.227953003617390e-014, 1.316988241100184e-013, 5.185336906425121e-013,
	1.970209678603344e-012, 7.224175781676820e-012, 2.556257202551268e-011,
	8.728933415057301e-011, 2.876459077365708e-010, 9.147356526491929e-010,
	2.807200293071396e-009, 8.313647035679894e-009, 2.376020324249415e-008,
	6.553134893509634e-008, 1.744168552591735e-007, 4.479898593205314e-007,
	1.110422626217248e-006, 2.656126831651419e-006, 6.131259576200486e-006,
	1.365812190078250e-005, 2.936112240141099e-005, 6.091085700995540e-005,
	1.219430782880170e-004, 2.355916997104800e-004, 4.392413365938098e-004,
	7.902905900637187e-004, 1.372179114501485e-003, 2.299191716915076e-003,
	3.717748055146816e-003, 5.801297154449817e-003, 8.735960373216617e-003,
	1.269511346313143e-002, 1.780339820034465e-002, 2.409403916531227e-002,
	3.146709895004599e-002, 3.965922170582210e-002, 4.823608546059376e-002,
	5.661614726353081e-002, 6.412818612763920e-002, 7.009676690120642e-002,
	7.394135519945359e-002, 7.526918477892675e-002, 7.394135519945361e-002,
	7.009676690120642e-002, 6.412818612763920e-002, 5.661614726353077e-002,
	4.823608546059376e-002, 3.965922170582214e-002, 3.146709895004599e-002,
	2.409403916531227e-002, 1.780339820034461e-002, 1.269511346313143e-002,
	8.735960373216637e-003, 5.801297154449817e-003, 3.717748055146816e-003,
	2.299191716915074e-003, 1.372179114501485e-003, 7.902905900637199e-004,
	4.392413365938098e-004, 2.355916997104800e-004, 1.219430782880168e-004,
	6.091085700995540e-005, 2.936112240141107e-005, 1.365812190078250e-005,
	6.131259576200486e-006, 2.656126831651410e-006, 1.110422626217248e-006,
	4.479898593205337e-007, 1.744168552591735e-007, 6.553134893509634e-008,
	2.376020324249398e-008, 8.313647035679894e-009, 2.807200293071416e-009,
	9.147356526491929e-010, 2.876459077365708e-010, 8.728933415057239e-011,
	2.556257202551268e-011, 7.224175781676870e-012, 1.970209678603344e-012,
	5.185336906425121e-013, 1.316988241100170e-013, 3.227953003617390e-014
}; // end table

const int firstnonzero_modulate=0; // use complete table
const int lastnonzero_modulate=80; // use complete table


float coeffs_table_predecimator [] = {
// generated by gnu octave fir1(12,0.5)
	 7.88886896155151e-05F,  9.10376113987996e-03F, -3.05693672260121e-04F,
	-5.78542250738291e-02F,  7.59303637549332e-04F,  3.01611829936953e-01F,
	 5.03901504919102e-01F,  3.01611829936953e-01F,  7.59303637549333e-04F,
	-5.78542250738291e-02F, -3.05693672260121e-04F,  9.10376113987997e-03F,
	 7.88886896155151e-05F
}; 


float coeffs_table_demodulate [] = {
// same filter as for 4800 bps modem. As we downsample the sampling-rate from 48 Khz to 24 Khz
// we can use the same filter for both filters
      -0.000153959924563F,  0.000000000000000F,  0.000167227768379F,
       0.000341615513437F,  0.000513334449696F,  0.000667493753523F,
       0.000783901543032F,  0.000838293462576F,  0.000805143268199F,
       0.000661865814384F,  0.000393913058926F, -0.000000000000000F,
      -0.000503471198655F, -0.001079755887508F, -0.001671728086040F,
      -0.002205032425392F, -0.002594597675000F, -0.002754194565297F,
      -0.002608210441859F, -0.002104352817854F, -0.001225654870420F,
       0.000000000000000F,  0.001494548041184F,  0.003130012785731F,
       0.004735238379172F,  0.006109242742194F,  0.007040527007323F,
       0.007330850462455F,  0.006821247169795F,  0.005417521811131F,
       0.003112202160626F, -0.000000000000000F, -0.003715739376345F,
      -0.007727358782391F, -0.011638713107503F, -0.014992029537478F,
      -0.017304097563429F, -0.018108937286588F, -0.017003180218569F,
      -0.013689829477969F, -0.008015928769710F,  0.000000000000000F,
       0.010154104792614F,  0.022059114281395F,  0.035162729807337F,
       0.048781621388364F,  0.062148583345584F,  0.074469032280094F,
       0.084982001723750F,  0.093020219991183F,  0.098063819576269F,
       0.099782731268437F,  0.098063819576269F,  0.093020219991183F,
       0.084982001723750F,  0.074469032280094F,  0.062148583345584F,
       0.048781621388364F,  0.035162729807337F,  0.022059114281395F,
       0.010154104792614F,  0.000000000000000F, -0.008015928769710F,
      -0.013689829477969F, -0.017003180218569F, -0.018108937286588F,
      -0.017304097563429F, -0.014992029537478F, -0.011638713107503F,
      -0.007727358782391F, -0.003715739376345F, -0.000000000000000F,
       0.003112202160626F,  0.005417521811131F,  0.006821247169795F,
       0.007330850462455F,  0.007040527007323F,  0.006109242742194F,
       0.004735238379172F,  0.003130012785731F,  0.001494548041184F,
       0.000000000000000F, -0.001225654870420F, -0.002104352817854F,
      -0.002608210441859F, -0.002754194565297F, -0.002594597675000F,
      -0.002205032425392F, -0.001671728086040F, -0.001079755887508F,
      -0.000503471198655F, -0.000000000000000F,  0.000393913058926F,
       0.000661865814384F,  0.000805143268199F,  0.000838293462576F,
       0.000783901543032F,  0.000667493753523F,  0.000513334449696F,
       0.000341615513437F,  0.000167227768379F,  0.000000000000000F,
      -0.000153959924563F
};

#else
	#if _INTMATH == 64
		// PART1 : DEMODULATION DATA: 32 bits used of 32 bits
		int32_t coeffs_table_demodulate [] = {
	 	  -330625,        0,    359119,     733614,   1102377,   1433432, 
	 	  1683416,  1800222,   1729032,    1421346,    845922,         0, 
	 	 -1081195,  -2318757, -3590008,   -4735270,  -5571855,  -5914587, 
	 	 -5601089,  -4519063, -2632073,          0,   3209518,   6721652, 
	 	 10168847,  13119499, 15119417,   15742881,  14648517,  11634040, 
	 	  6683403,         0, -7979489,  -16594376, -24993945, -32195137, 
		-37160267, -38888647, -36514051, -29398683, -17214075,         0, 
		 21805774,  47371588,  75511384, 104757736, 133463064, 159921024, 
		182497456, 199759408, 210590448, 214281776, 210590448, 199759408, 
		182497456, 159921024, 133463064, 104757736,  75511384,  47371588, 
		 21805774,         0, -17214075, -29398683, -36514051, -38888647, 
		-37160267, -32195137, -24993945, -16594376,  -7979489,         0, 
		  6683403,  11634040,  14648517,  15742881,  15119417,  13119499, 
		 10168847,   6721652,   3209518,         0,  -2632073,  -4519063, 
		 -5601089,  -5914587,  -5571855,  -4735270,  -3590008,  -2318757, 
		-1081195,          0,    845922,   1421346,   1729032,   1800222, 
		 1683416,    1433432,   1102377,    733614,    359119,         0, 
		  -330625
		}; // end table


		// PART 2: MODULATION data: 32 bits used of 32 bits
		int32_t coeffs_table_modulate [] = {
		0,0,0,
		0,0,0,
		0,0,1,
		6,17,51,
		140,374,962,
		2384,5703,13166,
		29330,63052,130805,
		261870,505929,943263,
		1697136,2946732,4937476,
		7983803,12458191,18760332,
		27262548,38232508,51741556,
		67575080,85167528,103586208,
		121582248,137714224,150531664,
		158787856,161639344,158787856,
		150531664,137714224,121582248,
		103586208,85167528,67575080,
		51741556,38232508,27262548,
		18760332,12458191,7983803,
		4937476,2946732,1697136,
		943263,505929,261870,
		130805,63052,29330,
		13166,5703,2384,
		962,374,140,
		51,17,6,
		1,0,0,
		0,0,0,
		0,0,0
		}; // end table
const int firstnonzero_modulate=8; // element 8 = 9th element in table
const int lastnonzero_modulate=72; // element 72 = 73 element in table


		int32_t coeffs_table_predecimator [] = {
		// generated by gnu octave fir1(12,0.5)
		    169412,  19550178,   -656472,
		-124241000,   1630592, 647706496,
		1082120192, 647706496,   1630592,
		-124241000,   -656472,  19550178,
		    169412
		}; 

#else
	#if _INTMATH == 3212
		// PART1 : DEMODULATION DATA: 20 bits used of 32 bits
		int32_t coeffs_table_demodulate [] = {
		  -160,      0,    175,    358,    538,    700,
         822,    879,    844,    694,    413,      0,
        -527,  -1131,  -1752,  -2311,  -2720,  -2887,
       -2734,  -2206,  -1284,      0,   1567,   3282,
        4965,   6406,   7383,   7687,   7153,   5681,
        3263,      0,  -3895,  -8102, -12203, -15719,
		-18144, -18988, -17828, -14354,  -8404,      0,
		 10647,  23131,  36871,  51151,  65168,  78086,
		 89110,  97539, 102827, 104630, 102827,  97539,
		 89110,  78086,  65168,  51151,  36871,  23131,
       10647,   	 0,  -8404, -14354, -17828, -18988,
      -18144, -15719, -12203,  -8102,  -3895,      0,
        3263,   5681,   7153,   7687,   7383,   6406,
        4965,   3282,   1567,      0,  -1284,  -2206,
		 -2734,  -2887,  -2720,  -2311,  -1752,  -1131,
        -527,      0,    413,    694,    844,    879,
         822,    700,    538,    358,    175, 		0,
        -160
		}; // end table

		// PART 2: MODULATION data: 20 bits used of 32 bits
		int32_t coeffs_table_modulate [] = {
		    0,     0,    0,      0,     0,     0,
		    0,     0,    0,      0,     0,     0,
		    0,     0,    0,      0,     1,     3,
		    7,    15,    31,    63,   123,   230,
		  414,   719,  1205,  1949,  3041,  4580,
		 6655,  9334, 12632, 16497, 20792, 25289,
		29683, 33621, 36750, 38766, 39462, 38766,
		36750, 33621, 29683, 25289, 20792, 16497,
		12632,  9334,  6655,  4580,  3041,  1949,
       1205,   719,   414,   230,   123,    63,
         31,    15,     7,     3,     1,     0,
          0,     0,     0,     0,     0,     0,
          0,     0,     0,     0,     0,     0,
          0,     0,     0
		}; // end table

const int firstnonzero_modulate=16; // element 16 = 17th element in table
const int lastnonzero_modulate=62; // element 62 = 63 element in table

		int32_t coeffs_table_predecimator [] = {
		// generated by gnu octave fir1(12,0.5)
		    41,   4772,   -160,
		-30332,    398, 158131,
		264189, 158131,    398,
		-30332,   -160,   4772,
		     41
		}; 


#else
	#if _INTMATH == 3210
		// PART1 : DEMODULATION DATA: 22 bits used of 32 bits
		int32_t coeffs_table_demodulate [] = {

		  -645,      0,    701,   1433,   2153,   2800,
        3288,   3516,   3377,   2776,   1652,      0,
       -2111,  -4528,  -7011,  -9248, -10882, -11551,
      -10939,  -8825,  -5140,      0,   6269,  13128,
       19861,  25624,  29530,  30748,  28610,  22723,
       13054, 		0,  -15584, -32410, -48815, -62880,
      -72578, -75953, -71316, -57418, -33620,      0,
       42589,  92523, 147483, 204605, 260670, 312346,
      356440, 390155, 411309, 418519, 411309, 390155,
      356440, 312346, 260670, 204605, 147483,  92523,
       42589,      0, -33620, -57418, -71316, -75953,
		-72578, -62880, -48815, -32410, -15584,      0,
       13054,  22723,  28610,  30748,  29530,  25624,
       19861,  13128,   6269,      0,  -5140,  -8825,
      -10939, -11551, -10882,  -9248,  -7011,  -4528,
       -2111,      0,   1652,   2776,   3377,   3516,
        3288,   2800,   2153,   1433,    701,      0,
        -645
		}; // end table

		// PART 2: MODULATION data: 22 bits used of 32 bits
		int32_t coeffs_table_modulate [] = {
		    0,       0,     0,       0,      0,      0,
		    0,       0,     0,       0,      0,      0,
		    0,       0,     0,       2,      5,     12,
		    28,     61,   127,     255,    494,    921,
		  1657,   2877,   4821,   7796,  12166,  18320,
		 26623,  37336,  50528,  65991,  83171, 101158,
		118732, 134486, 147003, 155066, 157850, 155066,
		147003, 134486, 118732, 101158,  83171,  65991,
		 50528,  37336,  26623,  18320,  12166,   7796,
		  4821,   2877,   1657,    921,    494,    255,
         127,     61,     28,     12,      5,      2,
           0,      0,      0,      0,      0,      0,
           0,      0,      0,      0,      0,      0,
           0,      0,      0
		}; // end table

const int firstnonzero_modulate=15; // element 15 = 16 element in table
const int lastnonzero_modulate=64; // element 64 = 65 element in table

		int32_t coeffs_table_predecimator [] = {
		// generated by gnu octave fir1(12,0.5)
		 165,   19091,    -641, -121329,
		1592,  632525, 1056758,  632525,
		1592, -121329,    -641,   19091,
		 165
		};

#endif
#endif
#endif
#endif


const int coeffs_size_demodulate=103;
const int buffersize_demodulate=2060; // coeffs_size_demodulate * 20;

const int coeffs_size_modulate=82;
const int buffersize_modulate=1640; // coeffs_size_modulate * 20;

const int coeffs_size_predecimator=13;
const int buffersize_predecimator=260; // coeffs_size_modulate * 20;

// some defines for the PLL (part of demodulation)

#define PLLMAX 3200 
#define PLLHALF 1600
// PLL increase = PLLMAX / 20
#define PLLINC 320

// INC = 32 (not used in application itself)
//#define INC 32

// SMALL PLL Increase = PLLINC / INC
#define SMALLPLLINC 10

///////////////////////////////////////
/// function firfilter for demodulation
// floating point math: input = float, output = float
// 64 bit integer math: input = 16 bit integer, output = 64 bit integer
// 32 bit integer math: input = 16 bit integer, output = 32 bit integer
#if _USEFLOAT == 1
float firfilter_demodulate(float val) {
#else
	#if _INTMATH == 64
	int64_t firfilter_demodulate(int16_t val) {
	#else
	// int32_20 and int32_22
	int32_t firfilter_demodulate(int16_t val) {
	#endif
#endif
static int pointer;
static int init=1;


//int64_t retval;
#if _USEFLOAT == 1
static float *buffer;
float retval;
float *ptr1;
float *ptr2;
#else
static int16_t *buffer;
int16_t *ptr1;
int32_t *ptr2;

	#if _INTMATH == 64 
	int64_t retval;
	#else
	// int32_20 and int32_22
	int32_t retval;
	#endif
#endif

int bufferloop;

if (init) {
	init=0;

	// allocate memory for buffer
#if _USEFLOAT == 1
	buffer=malloc(buffersize_demodulate * sizeof(float));
#else
	buffer=malloc(buffersize_demodulate * sizeof(int16_t));
#endif

	if (!buffer) {
		fprintf(stderr,"Error: could allocate memory for databuffer!\n");
		exit(-1);
	}; // end if


	// init buffer: all zero for first "coeffs_size_demodulate" elements.
#if _USEFLOAT == 1
	memset(buffer,0,coeffs_size_demodulate * sizeof(float));
#else
	memset(buffer,0,coeffs_size_demodulate * sizeof(int16_t));
#endif

	// init vars
	pointer=coeffs_size_demodulate;

	// END INIT
}; // end if

// main part of function starts here
buffer[pointer]=val;
pointer++;


// go throu all the elements of the coeffs table
ptr1=&buffer[pointer-coeffs_size_demodulate];
ptr2=coeffs_table_demodulate;

retval=0;
for (bufferloop=0;bufferloop<coeffs_size_demodulate;bufferloop++) {
#if _USEFLOAT == 1
	retval += (*ptr1++) * (*ptr2++);
#else
# if _INTMATH == 64
	retval += (((int64_t) *ptr1++) * ((int64_t) *ptr2++));
#else
	// int32_10 and int32_12
	retval += (*ptr1++ * *ptr2++);
#endif
#endif
}; // end for


// If pointer has moved past of end of buffer, copy last "coeffs_size_demodulate"
// elements to the beginning of the table and move pointer down
if (pointer >= buffersize_demodulate) {
#if _USEFLOAT == 1
	memmove(buffer,&buffer[buffersize_demodulate-coeffs_size_demodulate],coeffs_size_demodulate*sizeof(float));
#else
	memmove(buffer,&buffer[buffersize_demodulate-coeffs_size_demodulate],coeffs_size_demodulate*sizeof(int16_t));
#endif
	pointer=coeffs_size_demodulate;
}; // end if

return(retval);

};

///////////////////////////////////////
/// function firfilter for predecimator
// floating point math: input = float, output = float
// 64 bit integer math: input = 16 bit integer, output = 64 bit integer
// 32 bit integer math: input = 16 bit integer, output = 32 bit integer
#if _USEFLOAT == 1
float firfilter_predecimator(float val, int usebit) {
#else
	#if _INTMATH == 64
	int64_t firfilter_predecimator(int16_t val, int usebit) {
	#else
	// int32_20 and int32_22
	int32_t firfilter_predecimator(int16_t val, int usebit) {
	#endif
#endif
static int pointer;
static int init=1;


//int64_t retval;
#if _USEFLOAT == 1
static float *buffer;
float retval=0;
float *ptr1;
float *ptr2;
#else
static int16_t *buffer;
int16_t *ptr1;
int32_t *ptr2;

	#if _INTMATH == 64 
	int64_t retval=0;
	#else
	// int32_20 and int32_22
	int32_t retval=0;
	#endif
#endif

int bufferloop;

if (init) {
	init=0;

	// allocate memory for buffer
#if _USEFLOAT == 1
	buffer=malloc(buffersize_predecimator * sizeof(float));
#else
	buffer=malloc(buffersize_predecimator * sizeof(int16_t));
#endif

	if (!buffer) {
		fprintf(stderr,"Error: could allocate memory for databuffer firfilter predecimator!\n");
		exit(-1);
	}; // end if


	// init buffer: all zero for first "coeffs_size_predecimator" elements.
#if _USEFLOAT == 1
	memset(buffer,0,coeffs_size_predecimator * sizeof(float));
#else
	memset(buffer,0,coeffs_size_predecimator * sizeof(int16_t));
#endif

	// init vars
	pointer=coeffs_size_predecimator;

	// END INIT
}; // end if

// main part of function starts here
buffer[pointer]=val;
pointer++;

// if decimation used, only use value for 1 out of 2 bits, check LSB of "usebit"
if (usebit & 0x01) {
	// go throu all the elements of the coeffs table
	ptr1=&buffer[pointer-coeffs_size_predecimator];
	ptr2=coeffs_table_demodulate;

	retval=0;
	for (bufferloop=0;bufferloop<coeffs_size_predecimator;bufferloop++) {
	#if _USEFLOAT == 1
		retval += (*ptr1++) * (*ptr2++);
	#else
	# if _INTMATH == 64
		retval += (((int64_t) *ptr1++) * ((int64_t) *ptr2++));
	#else
		// int32_10 and int32_12
		retval += (*ptr1++ * *ptr2++);
	#endif
	#endif
	}; // end for
}; // end if (usebit?)

// If pointer has moved past of end of buffer, copy last "coeffs_size_demodulate"
// elements to the beginning of the table and move pointer down
if (pointer >= buffersize_predecimator) {
#if _USEFLOAT == 1
	memmove(buffer,&buffer[buffersize_predecimator-coeffs_size_predecimator],coeffs_size_predecimator*sizeof(float));
#else
	memmove(buffer,&buffer[buffersize_predecimator-coeffs_size_predecimator],coeffs_size_predecimator*sizeof(int16_t));
#endif
	pointer=coeffs_size_demodulate;
}; // end if

// if decimation used, only use value for 1 out of 2 bits, check LSB of "usebit"
if (usebit & 0x01) {
	return(retval);
} else {
	return(0);
}; // end else - if

};


///////////////////////////////////////
/// function firfilter for modulation
#if _USEFLOAT == 1
float firfilter_modulate(float val) {
#else
	#if _INTMATH == 64
	int64_t firfilter_modulate(int16_t val) {
	#else
	// int32_10 and int32_12
	int32_t firfilter_modulate(int16_t val) {
	#endif

#endif

static int pointer;
static int init=1;


#if _USEFLOAT == 1
static float *buffer;
float retval;
float *ptr1;
float *ptr2;
float *p_firstnonzero_modulate;
#else
static int16_t *buffer;
int16_t *ptr1;
int32_t *ptr2;
int32_t *p_firstnonzero_modulate;

	#if _INTMATH == 64
		int64_t retval;
	#else
		// int32_10 and int32_12
		int32_t retval;
	#endif

#endif

int bufferloop;


if (init) {
	init=0;

	// allocate memory for buffer
#if _USEFLOAT == 1
	buffer=malloc(buffersize_modulate * sizeof(float));
#else
	buffer=malloc(buffersize_modulate * sizeof(int16_t));
#endif

	if (!buffer) {
		fprintf(stderr,"Error: could allocate memory for databuffer!\n");
		exit(-1);
	}; // end if


	// init buffer: all zero for first "coeffs_size_demodulate" elements.
#if _USEFLOAT == 1
	memset(buffer,0,coeffs_size_modulate * sizeof(float));
#else
	memset(buffer,0,coeffs_size_modulate * sizeof(int16_t));
#endif

	// init vars

	pointer=coeffs_size_modulate;
	p_firstnonzero_modulate=&coeffs_table_modulate[firstnonzero_modulate];

	// END INIT
}; // end if

// main part of function starts here
buffer[pointer]=val;
pointer++;


// go throu all the elements of the coeffs table
ptr1=&buffer[pointer-coeffs_size_modulate];
ptr2=p_firstnonzero_modulate;

retval=0;
for (bufferloop=firstnonzero_modulate;bufferloop<=lastnonzero_modulate;bufferloop++) {
//printf("loop = %d, v = %d %d, retval = %d\n",bufferloop,*ptr1, *ptr2, retval);
#if _USEFLOAT == 1
	retval += (*ptr1++) * (*ptr2++);
#else
#if _INTMATH == 64
	retval += ((int64_t) *ptr1++) * ((int64_t) *ptr2++);
#else
	// int32_10 adn int32_1
	retval += (*ptr1++ * *ptr2++);
#endif
#endif
}; // end for


// If pointer has moved past of end of buffer, copy last "coeffs_size_demodulate"
// elements to the beginning of the table and move pointer down
if (pointer >= buffersize_modulate) {
#if _USEFLOAT == 1
	memmove(buffer,&buffer[buffersize_modulate-coeffs_size_modulate],coeffs_size_modulate*sizeof(float));
#else
	memmove(buffer,&buffer[buffersize_modulate-coeffs_size_modulate],coeffs_size_modulate*sizeof(int16_t));
#endif
	pointer=coeffs_size_modulate;
}; // end if

return(retval);

}; // end function firfilter_modulate


///////////////////////////////////////
/// function demodulate
int demodulate (int16_t audioin) {

static int init=1;
static int last;
static int m_pll;
static int bitselect;

#if _USEFLOAT == 1
float filterret_demod, filterret_predec;
#else
	#if _INTMATH == 64
	int64_t filterret_demod, filterret_predec;
	#else 
	int32_t filterret_demod, filterret_predec;
	#endif
#endif

int bit;


if (init) {
	init=0;
 
	// init vars
	last=0;
	m_pll=0;
	bitselect=0;

// end INIT part of function
}; // end if


// main part of function starts here

// apply demodulator only for 1 sample out of two
bitselect++;


#if _USEFLOAT == 1
// always apply predecimator filter
filterret_predec=firfilter_predecimator((float) audioin, bitselect);
#else
	#if _INTMATH == 3210
	// reduce audio to 10 bits (down from 16)
	filterret_predec=firfilter_predecimator(audioin >> 6, bitselect);
	#else
	#if _INTMATH == 3212
	// reduce audio to 12 bits (down from 16)
	filterret_predec=firfilter_predecimator(audioin >> 4, bitselect);
	#else
	// 64 bit integer math: process audio as 16 bits
	filterret_predec=firfilter_predecimator(audioin, bitselect);
	#endif
	#endif
#endif


// apply demodulator only for 1 sample out of two
if ((bitselect & 0x1) == 0) {
	// not 2nd bit, return
	return(-1);
}; // end if

// apply demodulator filter
filterret_demod=firfilter_demodulate(filterret_predec);

// determine bit: above or below zero

// audio invert: (0:no), 1:receive, (2:transmit), 3=both
if (g_global.audioinvert & 0x01) {
	if (filterret_demod > 0) {
		bit=0;
	} else {
		bit=1;
	}; // end else - if
} else {
	if (filterret_demod > 0) {
		bit=1;
	} else {
		bit=0;
	}; // end else - if
}; // end else - if


// PLL loop: used to detect exact 10 samples after when value passes over zero

if (bit != last) {
	if (m_pll < PLLHALF) {
		m_pll += SMALLPLLINC;
	} else {
		m_pll -= SMALLPLLINC;
	}; // end else - if
}; // end if

// store bit for next sample
last=bit;



m_pll += PLLINC;

// return here if not 10the sample
if (m_pll < PLLMAX) {
	return(-1);
}; // end if


// 10th sample

// reset PLL
m_pll -= PLLMAX;

// calculate and store data
return(bit);
			
}; // end function demodulate


